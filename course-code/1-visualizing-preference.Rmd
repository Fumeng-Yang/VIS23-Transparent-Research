---
title: "Visualizing the preference data"
output: 
  html_document: 
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
      smooth_scroll: no
    df_print: kable
    number_sections: yes
    theme: flatly
    highlight: tango
date: "`r format(Sys.time(), '%B %d, %Y')`"
author: "Fumeng Yang, Abhraneel Sarma, Maryam Hedayati"
---

This document provides the code for visualizing preference, 
Our research question is people's badge/button preference over two designs: `cat` and `logo`. They are measured by three statements, each on a 5-point Likert scale. The survey is at https://northwestern.az1.qualtrics.com/jfe/form/SV_1NqUXVkcvPvIKQm. 

```{css, echo=FALSE}
div {
  overflow: scroll;
}
```

# Introduction

We first load packages

```{r setup, message=FALSE}
library(tidyverse, quietly = TRUE) # data manipulation
library(ggdist, quietly = TRUE) # uncertainty vis
```

We then load the data


```{r, eval = FALSE}
read_csv('data/VIS23+tutorial_October+10,+2023_07.33.csv', col_names = TRUE, show_col_types = TRUE) |> 
  select(-IPAddress) |> 
  filter(row_number() > 3) |> 
  write.csv('data/vis23-tutorial_anon.csv', row.names = FALSE)
```


```{r}
df_raw <- read_csv('data/vis23-tutorial_anon.csv',
               col_names = TRUE, show_col_types = TRUE) |> 
          # we keep who finished the survey and filter out those generated by preview 
          filter(Finished == TRUE & DistributionChannel == 'anonymous')
```

Sanity check. 

```{r}
head(df_raw)
```

Qualtrics usually gives lots of columns. Here we want `cat_1`, ..., `logo_3` and a participant column.

```{r}
df = df_raw |> 
  # select the columns we need
  select('cat_1':'logo_3') |> 
  # add participantID
  mutate(participantID = paste0('P', row_number())) |>
  # move participantID to the first column
  relocate(participantID, .before = 1)
```


```{r}
head(df)
```


Let's continue transforming data into a more workable format.

```{r}
df_long = df |> 
  # move all responses into one column
  pivot_longer(cols = cat_1:logo_3, names_to = 'question', values_to = 'response') |> 
  # split the questions into design and question id
  separate(question, sep = '_', into = c('design', 'qid')) |> 
  mutate(design = as.factor(design), 
         qid = as.factor(paste0('q', qid)), 
         # transform responses into numeric format
         # this makes it easier for visualization
         # but this does not mean we consider them numeric responses!
         response = as.numeric(response))
```

The final data we will work with is 

```{r}
head(df_long)
```

```{r include=FALSE}
write_csv(x = df_long, file = 'data/preference.csv')
```


# Visualization

We set up a global theme and color preference. 

```{r message=FALSE}
theme_set(
  theme_ggdist() + 
    theme(
      axis.text = element_text(size = 12),
      axis.title = element_text(size = 14)
    )
)

scale_color_vis23 = \(...) scale_color_manual(..., 
                                              values = c("cat" = '#e888b3', 
                                                         "logo" ='#277cbd'),
                                              aesthetics = c("color", "fill")
)

```


## raw data

So if we juts plot raw data, they are going to overlap with each other

```{r, fig.height = 2, fig.width = 7}
df_long |> 
  ggplot(aes(x = response, y = design, color = design)) + 
  geom_point(size = 2) +
  scale_color_vis23()
```
One thing we can do is to add a bit of jitterinbg to move them away from each other

```{r, fig.height = 2.5, fig.width = 7}
df_long |> 
  ggplot(aes(x = response, y = design, color = design)) + 
  # we don't want the responses to move around their scale
  # so we only jitter y axis
  # we add a seed to get the same layout everytime
  geom_point(size = 2, position = position_jitter(width = 0, height = .2, seed = 1234), alpha = 0.7) +
  scale_color_vis23()
```
We may also want to know different questions.

```{r, fig.height = 2.5, fig.width = 7}
df_long |> 
  ggplot(aes(x = response, y = design, color = design, shape = qid)) + 
  # we don't want the responses to move around their scale
  # so we only jitter y axis
  # we add a seed to get the same layout everytime
  geom_point(size = 2, position = position_jitter(width = 0, height = .2, seed = 1234), alpha = .7) +
  scale_color_vis23()
```

```{r, fig.height = 4, fig.width = 7}
df_long |> 
  ggplot(aes(x = response, y = design, color = design)) + 
  # we don't want the responses to move around their scale
  # so we only jitter y axis
  # we add a seed to get the same layout everytime
  geom_point(position = position_jitter(width = 0, height = .2, seed = 1234), size = 2, alpha = 0.7) +
  facet_wrap(qid ~ ., ncol = 1) + 
  scale_color_vis23()
```

## portion & counts

Another way to think about the visualization is to show the counts or the portion.

```{r, fig.height = 3, fig.width = 7}
df_long |> 
  group_by(design, qid, response) |> 
  reframe(n = n()) |> 
  ggplot(aes(x = response, y = n, fill = design)) + 
  geom_bar(position="dodge", stat="identity") +
  scale_color_vis23() +
  ylab('counts')
```

We can also try a different layout.

```{r, fig.height = 3, fig.width = 7}
df_long |> 
  group_by(design, qid, response) |> 
  reframe(n = n()) |> 
  ggplot(aes(x = response, y = n, fill = design)) + 
  geom_bar(position="stack", stat="identity") +
  scale_color_vis23() +
  ylab('counts')
```

We can also visualize them by portion. Different gradients mean different responses.

```{r, fig.height = 3, fig.width = 7}
df_long |> 
  group_by(design, response) |> 
  reframe(n = n()) |> 
  ggplot(aes(x = design, fill = design, y = n, alpha = response)) + 
  geom_bar(position="fill", stat="identity", width = 0.5) +
  scale_y_continuous(breaks = seq(0, 1, by = 0.2)) +
  ylab('portion') +
  scale_color_vis23() +
  coord_flip()
```
## Partially-aggregated data

The assumption behind a Likert scale is that the responses are generated from an underlying normal distribution. So, we can either average these ordinal responses first and then analyze the average, or we can model them using an ordinal regression first and then average the posteriors. 

We can also first aggregate each participant's responses to generate mean and standard deviation. 

```{r}
df_aggregated = df_long |> 
  # we aggregate per participant x design
  group_by(participantID, design) |> 
  reframe(mean_response = mean(response), sd_response = sd(response))
```

```{r}
head(df_aggregated)
```


```{r, fig.height = 3, fig.width = 7}
df_aggregated |> 
  ggplot(aes(x = mean_response, y = design, color = design)) + 
  geom_point(position = position_jitter(width = 0, height = .2, seed = 1234), size = 2, alpha = 0.8) +
  scale_color_vis23()
```

We can also possibly draw a density plot or histogram (this should be better if we have more data)

```{r}
df_aggregated |> 
  ggplot(aes(x = mean_response, fill = design)) + 
  geom_histogram() + 
  facet_wrap(design ~ .) + 
  scale_color_vis23() 
```

```{r}
df_aggregated |> 
  ggplot(aes(x = mean_response, fill = design)) + 
  stat_slab(alpha = .5) + 
  scale_color_vis23() 
```

# Session Info

```{r}
sessionInfo()
```

